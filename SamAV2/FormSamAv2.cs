using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using System.Threading;
using GS.Apdu;
using GS.PCSC;
using GS.SCard;
using GS.SCard.Const;
using GS.Util.Hex;


namespace SamAV2
{
    public partial class FormSamAv2 : Form
    {
        private const string mVersion = " V1.00";
        private PCSCReader mPcscReader = new PCSCReader();
        //private string mReaderName;
        private bool mIsReaderConnected = false;
        private MultiLine mlText = new MultiLine();
        private RespApdu mRespApdu;
        private byte[] mThsrcFileProtectKey = new byte[] {0x0C, 0xAE, 0xAA, 0xA0, 0x50, 0x9A, 0xBC, 0x24,
                                                          0x5C, 0x76, 0x1E, 0xB0, 0xB8, 0x70, 0xE6, 0xD2};
        private byte[] mThsrcIV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0,
                                               0, 0, 0, 0, 0, 0, 0, 0};
        private byte[] mThsrcKeyFileData = new byte[0];
        private byte[] mThsrcOrgKey = new byte[16];
        private byte[] mThsrcUsageMasterKey = new byte[0];  //[16];
        private byte[] mThsrcUsageKey = new byte[0]; //[16]; 
        private byte[] mThsrcSessionKey = new byte[16]; //The session key generated by Host Authen.
        private byte[] mThsrcSamSN = new byte[16];
        private bool mIsThsrcSamAuthed = false;

        private byte mSamType = 0; //A1: SAM AV1 Mode, A2: SAM AV2 Mode, other: Non-SAM AV2

        private int mSelectedPortNo = 0; //The selected RS232 Port No.
        private bool mIsPortOpened = false;

        //private byte Atq = 0x00;
        private byte[] mbaCardSnr = new byte[10];
        private string mstrCardSnr = "";
        private byte[] mTagType = new byte[2]; //Same as ATQA
        //private byte CardMode = 0;
        //private int SnrLength = 0;
        private byte mbSnrLen = 0; //The length of PICC card serial number
        private byte mSAK = 0;
        private uint mSpentTime = 0;
        private byte[] mbaATQA = new byte[2];
        private byte[] mbaPiccRecvBuf = new byte[256];
        //private byte mPiccRecvLen = 0;
        private bool mIsPiccExisted = false; //true if card request has been passed.

        private bool mIsPiccAuthened = false; //true: if the Picc has been passed the first authened.


        public FormSamAv2()
        {
            try
            {
                InitializeComponent();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString()); //for debug only
            }

        }

        private int ListReaders()
        {
            try
            {
                string[] readerList = mPcscReader.ListReaders();

                if (readerList == null || readerList.Length <= 0)
                    return 0;

                Array.Sort(readerList);

                comboReaders.Items.AddRange(readerList);
                comboReaders.SelectedIndex = 0;

                return readerList.Length;
            }
            catch (Exception e)
            {
                throw e;
            }
        }

        // For .Net 3.5 and below, 
        // the portname of virtual port (especially for Bluetooth Comport) will be attached some garbage characters
        // sometimes.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Portname"></param>
        private string TrimPortName(string Portname)
        {
            try
            {
                if (Portname.Length <= 4)
                    return Portname;

                byte[] baPortname = System.Text.Encoding.ASCII.GetBytes(Portname);
                int nEndAddr = Portname.Length - 1;

                //註: .Net 3.5有個 Bug, 藍芽 Com Port Name 後面會帶個亂碼, 必須把它去掉,
                //    據說 .Net 4.0 就沒這問題了.
                if (baPortname[nEndAddr] < 0x30 || baPortname[nEndAddr] > 0x39)
                    return Portname.Remove(nEndAddr);
                else
                    return Portname;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private int SearchAndSetComPortBox()
        {
            try
            {
                string[] ports = System.IO.Ports.SerialPort.GetPortNames();

                if (ports.Length <= 0)
                    return 0;

                //Sometimes, the portname of virtual port will be attached some garbage characters.
                for (int i = 0; i < ports.Length; i++)
                    ports[i] = TrimPortName(ports[i]);

                Array.Sort(ports);

                comboComPorts.Items.AddRange(ports);
                comboComPorts.SelectedIndex = 0;

                return ports.Length;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void FormSamAv2_Load(object sender, EventArgs e)
        {
            this.Text += mVersion;
#if DEBUG
            this.Text += " - Debug";
#endif

            try
            {
                //=========== Initial PCSC Reader =============
                int ReaderCount = ListReaders();
                
                if (chkSaveLog.Checked)
                    mlText.ToSaveLog = true;
                else
                    mlText.ToSaveLog = false;

                mlText.AddLine("**** SAM AV2 Demo程式開始 ****");
                if (ReaderCount > 0)
                {
                    //PortName = (string)comboReaders.SelectedItem;
                    btnConnect.Enabled = true;
                    mlText.AddLine(String.Format("發現有 {0} 台 PCSC 讀卡機, 請先選擇要使用的讀卡機, 並確認己插入晶片卡",
                                          ReaderCount));
                    btnConnect.Focus();
                }
                else
                {
                    btnConnect.Enabled = false;
                    btnDisconnect.Enabled = false;

                    mlText.AddLine("沒發現 PCSC 讀卡機, 請確認讀卡機是否正常連接, 並重新執行本程式");
                    btnExit.Focus();
                }
                
                txtThsrcKeyFile.Text = System.Windows.Forms.Application.StartupPath + @"\ThsrcUsageKey.bin";

                //++++++ Initial MRD Reader +++++++
                int PortCount = SearchAndSetComPortBox();
                string PortName = "";
                int PortNo = 0;

                if (PortCount <= 0)
                {
                    mlText.AddLine("Warning: No COM Port Found. The MRD Reader may not be opened!");
                    btnComOpen.Enabled = false;
                    btnComClose.Enabled = false;
                }
                else
                {
                    PortName = (string)comboComPorts.SelectedItem;
                    PortNo = Convert.ToInt32(PortName.Remove(0, 3)) - 1;
                }

                byte[] baLibVersion = new byte[80];
                MrdDll.MRD_ApiVersion(baLibVersion);

                string strLibVersion = System.Text.Encoding.UTF8.GetString(baLibVersion);
                txtLibVersion.Text = strLibVersion;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString()); //for debug only
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void FormSamAv2_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (mIsReaderConnected)
                mPcscReader.Disconnect();

            if (mIsPortOpened)
                OnComCloseClick();
        }

        private void btnConnect_Click(object sender, EventArgs e)
        {
            try
            {
                string readerName = (string)comboReaders.SelectedItem;

                mPcscReader.Connect(readerName);
                mPcscReader.ActivateCard();

                txtATR.Text = mPcscReader.SCard.AtrString;
                txtProtocol.Text = mPcscReader.SCard.SCardProtocol.ToString();
                //lblProtocol.Visible = true;

                mIsReaderConnected = true;
                btnConnect.Enabled = false;
                btnDisconnect.Enabled = true;
                btnSendApdu.Enabled = true;
                txtAPDU.Enabled = true;
                tabControl.Enabled = true;
                mSamType = 0;
                mIsThsrcSamAuthed = false;

                mlText.NewLine();
                mlText.AddLine("IsCardPresent = " + mPcscReader.SCard.IsCardPresent);
                txtAPDU.Focus();
            }
            catch (Exception ex)
            {
                mPcscReader.Disconnect();
                mlText.AddLine(ex.ToString());
                mlText.AddLine("卡片連接失敗, 請檢查卡片是否己正確插入讀卡機");
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void btnDisconnect_Click(object sender, EventArgs e)
        {
            btnConnect.Enabled = true;
            btnDisconnect.Enabled = false;
            txtATR.Text = "";
            txtProtocol.Text = "";
            //lblProtocol.Visible = false;
            btnSendApdu.Enabled = false;
            txtAPDU.Enabled = false;
            tabControl.Enabled = false;

            mPcscReader.Disconnect();
            mIsReaderConnected = false;
            mIsThsrcSamAuthed = false;

            btnExit.Focus();
        }

        private void btnClearMessage_Click(object sender, EventArgs e)
        {
            txtMessage.Text = mlText.Clear();
        }

        private void btnExit_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        //
        // To scroll down the text message box automatically
        private void txtMessage_TextChanged(object sender, EventArgs e)
        {
            txtMessage.SelectionStart = txtMessage.Text.Length;
            txtMessage.ScrollToCaret();
        }

        private ushort SendShowApdu(string strApdu)
        {
            try
            {
                mRespApdu = mPcscReader.Exchange(strApdu);

                mlText.AddLine("Send: " + strApdu);
                if (mRespApdu.Data != null && mRespApdu.Data.Length > 0)
                {
                    mlText.AddLine(String.Format("Resp({0}B): {1}", mRespApdu.Data.Length,
                        HexFormatting.ToHexString(mRespApdu.Data, true)));
                }
                else
                {
                    mlText.AddLine("Resp: (None)");
                }

                //mlText.AddLine("Status: " + mRespApdu.SW1SW2.Value.ToString("X4"));
                mlText.AddLine(String.Format("Status: {0}, {1}",
                                mRespApdu.SW1SW2.Value.ToString("X4"),
                                AV2SW.ToString((UInt16)mRespApdu.SW1SW2)));

                return mRespApdu.SW1SW2 ?? 0;
            }
            catch (WinSCardException ex)
            {
                mlText.AddLine(ex.WinSCardFunctionName + " Error 0x" +
                                   ex.Status.ToString("X08") + ": " + ex.Message);
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }

            return 0;
        }

        private void btnSendApdu_Click(object sender, EventArgs e)
        {
            try
            {
                mlText.NewLine();
                SendShowApdu(txtAPDU.Text);
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void txtAPDU_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Return)
            {
                btnSendApdu_Click(sender, e);
            }
        }

        private void txtAPDU_KeyPress(object sender, KeyPressEventArgs e)
        {
            if ((e.KeyChar >= '0' && e.KeyChar <= '9') ||
                (e.KeyChar >= 'A' && e.KeyChar <= 'F') ||
                (e.KeyChar >= 'a' && e.KeyChar <= 'f') ||
                (e.KeyChar == ' ') ||
                (e.KeyChar == 0x08))
            {
                e.KeyChar = Char.ToUpper(e.KeyChar);
                e.Handled = false;
            }
            else
            {
                e.Handled = true; //Ignore the input key
            }
        }

        private void btnGetVersion_Click(object sender, EventArgs e)
        {
            try
            {
                mlText.NewLine();
                mlText.AddLine("== SAM_GetVersion ==");
                ushort uSW = SendShowApdu("8060000000");

                if (uSW == 0x9000)
                {
                    if (mRespApdu.Data[3] == 0x03)
                        mlText.AddLine(" -SAM AV2, Chip Model: T1AD2060.");
                    else if (mRespApdu.Data[3] == 0x04)
                        mlText.AddLine(" -SAM AV2, Chip Model: T1AR1070.");
                    else
                        mlText.AddLine(" -SAM AV2, Chip Model: (Undefined).");
                    
                    byte[] baSamSN = new byte[7];
                    Array.Copy(mRespApdu.Data, 14, baSamSN, 0, 7);

                    mlText.AddLine(String.Format(" -SAM S/N: {0}",
                        HexFormatting.ToHexString(baSamSN, true)));

                    //Production Date: dd/mm/yyyy
                    mlText.AddLine(String.Format(" -Production Date: {0}/{1}/20{2}",
                        mRespApdu.Data[26].ToString("D2"),
                        mRespApdu.Data[27].ToString("D2"),
                        mRespApdu.Data[28].ToString("D2")));

                    mlText.AddLine(String.Format(" -High Byte of ProMas: {0}",
                        mRespApdu.Data[29].ToString("D2")));

                    mSamType = mRespApdu.Data[30];
                    if (mSamType == 0xA1)
                        mlText.AddLine(" -SAM Mode: AV1 compatibility mode.");
                    else if (mSamType == 0xA2)
                        mlText.AddLine(" -SAM Mode: AV2 mode.");
                    else
                        mlText.AddLine(" -SAM Mode: (Undefined).");
                }
                txtMessage.Text = mlText.Text;
            }
            catch (Exception ex)
            {
                txtMessage.Text = mlText.AddLine(ex.Message);
            }
        }

        /***
         * ParsingSET: A subroutine used for GetKeyEntry()
         * */
        private void ParsingSET(UInt16 uSet)
        {
            try
            {
                mlText.AddLine(String.Format("  *SET = 0x{0}", uSet.ToString("X4")));

                //bit 0
                if((uSet & 0x01) == 0)
                    mlText.AddLine("  .Bit_0 = 0, Dump Session Key/ Mifare Key aren't allowed.");
                else
                    mlText.AddLine("  .Bit_0 = 1, Dump Session Key/ Mifare Key are allowed.");

                //bit 1
                if (((uSet >> 1) & 0x01) == 0)
                    mlText.AddLine("  .Bit_1 = 0, All crypto will be based on the session key that generated by authen.");
                else
                    mlText.AddLine("  .Bit_1 = 1, All crypto will be based on the secret key itself but not session key.");

                //bit 2
                if (((uSet >> 2) & 0x01) == 0)
                    mlText.AddLine("  .Bit_2 = 0, Don't keep IV, the IV will be reset automatically after crypto.");
                else
                    mlText.AddLine("  .Bit_2 = 1, The IV will be kept after crypto.");

                //bit 3 ~ 5
                switch ((uSet >> 3) & 0x07)
                {
                    case 0:
                        mlText.AddLine("  .Bit_3~5 = 000, key type: TDEA DESFire 4");
                        break;
                    case 1:
                        mlText.AddLine("  .Bit_3~5 = 001, key type: TDEA ISO 10116 (16-bit CRD, 4-byte MAC)");
                        break;
                    case 2:
                        mlText.AddLine("  .Bit_3~5 = 010, key type: Mifare");
                        break;
                    case 3:
                        mlText.AddLine("  .Bit_3~5 = 011, key type: 3TDEA ISO 10116 (168-bit)");
                        break;
                    case 4:
                        mlText.AddLine("  .Bit_3~5 = 100, key type: AES 128");
                        break;
                    case 5:
                        mlText.AddLine("  .Bit_3~5 = 101, key type: AES 192");
                        break;
                    case 6:
                        mlText.AddLine("  .Bit_3~5 = 110, key type: TDEA ISO 10116 (32-bit CRC, 8-byte MAC)");
                        break;
                    case 7:
                        mlText.AddLine("  .Bit_3~5 = 111, key type: (Error)");
                        break;
                }

                //bit 6, 7
                mlText.AddLine("  .Bit_6, 7 = RFU (Must be set to 0).");

                //bit 8
                if (mSamType == 0xA1)
                {
                    if (((uSet >> 8) & 0x01) == 0)
                        mlText.AddLine("  .Bit_8 = 0, Higher command security level by CMAC is disabled.");
                    else
                        mlText.AddLine("  .Bit_8 = 1, Higher command security level by CMAC is enabled.");
                }
                else
                {
                    if (((uSet >> 8) & 0x01) == 0)
                        mlText.AddLine("  .Bit_8 = 0, AV2 Mode, AuthKey disable.");
                    else
                        mlText.AddLine("  .Bit_8 = 1, AV2 Mode, AuthKey enable.");
                }

                //bit 9
                if (((uSet >> 9) & 0x01) == 0)
                    mlText.AddLine("  .Bit_9 = 0, The key entry is enabled and can be used.");
                else
                    mlText.AddLine("  .Bit_9 = 1, The key entry is disabled.");

                //bit 10
                if (mSamType == 0xA1)
                {
                    if (((uSet >> 10) & 0x01) == 0)
                        mlText.AddLine("  .Bit_10 = 0, (Only for KeyNo 00)No host authentication after reset is required. (RFU:0 for other Keys).");
                    else
                        mlText.AddLine("  .Bit_10 = 1, (Only for KyeNo 00)Enable host authentication after reset.");
                }
                else
                {
                    if (((uSet >> 10) & 0x01) == 0)
                        mlText.AddLine("  .Bit_10 = 0, AV2 Mode, LockKey disable.");
                    else
                        mlText.AddLine("  .Bit_10 = 1, AV2 Mode, LockKey enable.");
                }

                //bit 11
                if (((uSet >> 11) & 0x01) == 0)
                    mlText.AddLine("  .Bit_11 = 0, Keys in this entry can be downloaded into a DESFire PICC with SAM_Change_Key_PICC.");
                else
                    mlText.AddLine("  .Bit_11 = 1, block SAM_Change_Key_PICC. Keys in this entry can't be downloaded into a DESFire PICC.");

                //bit 12
                if (((uSet >> 12) & 0x01) == 0)
                    mlText.AddLine("  .Bit_12 = 0, This key entry can be used to decrypt data with SAM_DecipherData.");
                else
                    mlText.AddLine("  .Bit_12 = 1, block SAM_DecipherData. This key entry can't be used to decrypt data.");

                //bit 13
                if (((uSet >> 13) & 0x01) == 0)
                    mlText.AddLine("  .Bit_13 = 0, This key entry can be used to encrypt data with SAM_EncipherData.");
                else
                    mlText.AddLine("  .Bit_13 = 1, block SAM_EncipherData. This key entry can't be used to encrypt data.");

                //bit 14
                if (((uSet >> 14) & 0x01) == 0)
                    mlText.AddLine("  .Bit_14 = 0, This key entry can be used to verify MACs with SAM_VeryfyMAC.");
                else
                    mlText.AddLine("  .Bit_14 = 1, block SAM_VeryfyMAC. This key entry can't be used to verify MACs.");

                //bit 15
                if (((uSet >> 15) & 0x01) == 0)
                    mlText.AddLine("  .Bit_15 = 0, This key entry can be used to generate MACs with SAM_Generate_MAC.");
                else
                    mlText.AddLine("  .Bit_15 = 1, block SAM_Generate_MAC. This key entry can't be used to generate MACs.");
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }


        /***
         * ParsingExtSET: A subroutine used for GetKeyEntry()
         * */
        private void ParsingExtSET(byte bExtSet)
        {
            try
            {
                //mlText.AddLine(String.Format(" -ExtSET: {0}h (used for AV2 Mode only)", bExtSet.ToString("X2")));

                //bit 0 ~ 2
                switch (bExtSet & 0x07)
                {
                    case 0:
                        mlText.AddLine("  .Bit_0~2 = 000, Host Key: used for SAM-Host communication.");
                        break;
                    case 1:
                        mlText.AddLine("  .Bit_0~2 = 001, PICC Key: used for SAM-PICC communication.");
                        break;
                    case 2:
                        mlText.AddLine("  .Bit_0~2 = 010, OfflineChange Key: used for key management.");
                        break;
                    case 4:
                        mlText.AddLine("  .Bit_0~2 = 100, OfflineCrypto Key: used for cryptographic processing.");
                        break;
                    default:
                        mlText.AddLine(String.Format("  .Bit_0~2 = {0}, Undefined Key Type",
                            (int)(bExtSet & 0x07)));
                        break;
                }

                //bit 3
                if (((bExtSet >> 3) & 0x01) == 0)
                    mlText.AddLine("  .Bit_3 = 0, The command SAM_DumpSecretKey isn't allowed.");
                else
                    mlText.AddLine("  .Bit_3 = 1, The command SAM_DumpSecretKey is allowed for this key entry.");

                //bit 4
                if (((bExtSet >> 4) & 0x01) == 0)
                    mlText.AddLine("  .Bit_4 = 0, Diversification when using this key entry isn't mandatory.");
                else
                    mlText.AddLine("  .Bit_4 = 1, Diversification when using this key entry is mandatory.");
                mlText.AddLine("  .Bit_5~7 = RFU (Must be set to 0).");
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }


        private ushort GetKeyEntry(int nKeyNo)
        {
            try
            {
                mlText.NewLine();
                mlText.AddLine(String.Format("== KeyNo:{0}, SAM_GetKeyEntry ==", nKeyNo));
                //string strApdu = string.Format("8064{0}0000", nKeyNo.ToString("X2"));
                ushort uSW = SendShowApdu(string.Format("8064{0}0000", nKeyNo.ToString("X2")));

                if (uSW == 0x9000)
                {
                    bool IsVcExist = true;
                    int offset = 0;

                    if ((mRespApdu.Data.Length == 11) ||
                       (mRespApdu.Data.Length == 12 && mSamType == 0xA2))
                        IsVcExist = false;

                    mlText.AddLine(String.Format(" -Va (Version of Key a): {0}h",
                        mRespApdu.Data[offset++].ToString("X2")));

                    mlText.AddLine(String.Format(" -Vb (Version of Key b): {0}h",
                        mRespApdu.Data[offset++].ToString("X2")));

                    if (IsVcExist)
                        mlText.AddLine(String.Format(" -Vc (Version of Key c): {0}h",
                            mRespApdu.Data[offset++].ToString("X2")));
                    else
                        mlText.AddLine(" -Vc (Version of Key c): (None)");

                    byte[] baDfAid = new byte[3];
                    Array.Copy(mRespApdu.Data, offset, baDfAid, 0, 3);
                    mlText.AddLine(String.Format(" -DF_AID: {0}h",
                        HexFormatting.ToHexString(baDfAid, true)));
                    offset += 3;

                    mlText.AddLine(String.Format(" -DF_KeyNo: {0}h",
                        mRespApdu.Data[offset++].ToString("X2")));

                    mlText.AddLine(String.Format(" -KeyNoCEK (KeyNo of Change Entyr Key): {0}h ({1}d)",
                        mRespApdu.Data[offset].ToString("X2"),
                        mRespApdu.Data[offset].ToString("D2")));

                    if (mRespApdu.Data[offset] == 0xFE)
                        mlText.AddLine("   .The value FEh disables the need for authentication for key load.");
                    else if (mRespApdu.Data[offset] == 0xFF)
                        mlText.AddLine("   .The value FFh irreversibly locks the entire key entry.");
                    offset++;

                    mlText.AddLine(String.Format(" -KeyVCEK (KeyVer of Change Entyr Key): {0}h",
                        mRespApdu.Data[offset++].ToString("X2")));

                    if (mRespApdu.Data[offset] == 0xFF)
                        mlText.AddLine(String.Format(" -RefNoKUC (RefNo of Key Usage Counter): {0}h, No KUC is used.",
                            mRespApdu.Data[offset].ToString("X2")));
                    else
                        mlText.AddLine(String.Format(" -RefNoKUC (RefNo of Key Usage Counter): {0}h",
                            mRespApdu.Data[offset].ToString("X2")));
                    offset++;

                    mlText.AddLine(String.Format(" -SET: {0} {1} h",
                        mRespApdu.Data[offset].ToString("X2"),
                        mRespApdu.Data[offset + 1].ToString("X2")));

                    UInt16 uSET = BitConverter.ToUInt16(mRespApdu.Data, offset);
                    ParsingSET(uSET);

                    if (mSamType == 0xA2)
                    {
                        offset += 2;
                        mlText.AddLine(String.Format(" -ExtSET: {0}h (for AV2 Mode only)",
                            mRespApdu.Data[offset].ToString("X2")));

                        ParsingExtSET(mRespApdu.Data[offset]);
                    }
                }

                return uSW;
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            return 0;
        }

        private void btnGetKeyEntry_Click(object sender, EventArgs e)
        {
            try
            {
                if (mSamType == 0)
                {
                    btnGetVersion_Click(sender, e);

                    if (mSamType == 0)
                    {
                        mlText.AddLine("Error: SAM AV2 isn't found!");
                        return;
                    }
                }

                int nKeyNo = int.Parse(txtKeyNo.Text);
                GetKeyEntry(nKeyNo);
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void chkSaveLog_CheckedChanged(object sender, EventArgs e)
        {
            if (chkSaveLog.Checked == true)
                mlText.ToSaveLog = true;
            else
                mlText.ToSaveLog = false;
        }

        private void txtKeyNo_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Return)
            {
                btnGetKeyEntry_Click(sender, e);
            }
        }

        private void btnDumpAllKeyEntries_Click(object sender, EventArgs e)
        {
            try
            {
                if (mSamType == 0)
                {
                    btnGetVersion_Click(sender, e);

                    if (mSamType == 0)
                    {
                        mlText.AddLine("Error: SAM AV2 isn't found!");
                        return;
                    }
                }

                tabControl.Enabled = false;
                for (int nKeyNo = 0; nKeyNo <= 127; nKeyNo++)
                {
                    GetKeyEntry(nKeyNo);
                    txtMessage.Text = mlText.Text;
                }
                tabControl.Enabled = true;
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void btnSelectKeyFile_Click(object sender, EventArgs e)
        {
            try
            {
                OpenFileDialog openFileDialog = new OpenFileDialog();
                openFileDialog.InitialDirectory = System.Windows.Forms.Application.StartupPath;
                openFileDialog.Filter = "BIN Files (*.bin)|*.bin|" +
                                         "All Files (*.*)|*.*";
                openFileDialog.FileName = "ThsrcUsageKey.bin";
                openFileDialog.CheckFileExists = true;
                openFileDialog.CheckPathExists = true;
                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    txtThsrcKeyFile.Text = openFileDialog.FileName;
                    mlText.AddLine(String.Format("Key file {0} is selected!", openFileDialog.FileName));
                }
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void chkDesCbcMode_CheckedChanged(object sender, EventArgs e)
        {
            if (chkDesCbcMode.Checked == true)
            {
                txtDesCbcIV.Enabled = true;
            }
            else
            {
                txtDesCbcIV.Enabled = false;
            }
        }

        private void radio3TDEA_CheckedChanged(object sender, EventArgs e)
        {
            if (radio3TDEA.Checked == true)
            {
                txtDesKey2.Enabled = true;
                txtDesKey3.Enabled = true;
            }
        }

        private void radio2TDEA_CheckedChanged(object sender, EventArgs e)
        {
            if (radio2TDEA.Checked == true)
            {
                txtDesKey2.Enabled = true;
                txtDesKey3.Enabled = false;
            }
        }

        private void radioDES_CheckedChanged(object sender, EventArgs e)
        {
            if (radioDES.Checked == true)
            {
                txtDesKey2.Enabled = false;
                txtDesKey3.Enabled = false;
            }
        }

        private void btnDesEncryption_Click(object sender, EventArgs e)
        {
            try
            {
                string strDesKey1 = txtDesKey1.Text.Replace(" ", "");
                string strDesKey2 = txtDesKey2.Text.Replace(" ", "");
                string strDesKey3 = txtDesKey3.Text.Replace(" ", "");
                string strDesCbcIV = txtDesCbcIV.Text.Replace(" ", "");
                string strDesPlainData = txtDesPlainData.Text.Replace(" ", "");
                string strKey = strDesKey1; //Default value for DES 
                byte[] baKey;
                byte[] baPlainData;
                byte[] baCypherData = new byte[0];
                string strCypherData;

                if (String.IsNullOrEmpty(strDesKey1))
                {
                    mlText.AddLine("Error: The field of Key1 can't be empty.");
                    return;
                }

                if (strDesKey1.Length < 16)
                {
                    mlText.AddLine(
                                String.Format("Error: The length of Key 1 is {0} but it should be 16",
                                         strDesKey1.Length));
                    return;
                }

                if (String.IsNullOrEmpty(strDesPlainData))
                {
                    mlText.AddLine("Error: The field of Plain Data can't be empty.");
                    return;
                }

                if (chkDesCbcMode.Checked == true &&
                    String.IsNullOrEmpty(strDesCbcIV))
                {
                    strDesCbcIV = "0000000000000000"; //Default Value
                    txtDesCbcIV.Text = strDesCbcIV;
                }

                if (radioDES.Checked == false &&  //The Key2 can't be empty in this case
                    String.IsNullOrEmpty(strDesKey2))
                {
                    strDesKey2 = strDesKey1;
                    txtDesKey2.Text = strDesKey2;
                }

                if (radio3TDEA.Checked == true &&  //The Key3 can't be empty in this case
                    String.IsNullOrEmpty(strDesKey3))
                {
                    strDesKey3 = strDesKey1;
                    txtDesKey3.Text = strDesKey3;
                }

                baPlainData = TDEA.ToByteArray(strDesPlainData);

                if (radio2TDEA.Checked == true)//2TDEA
                {
                    strKey = strDesKey1 + strDesKey2;
                }
                else if (radio3TDEA.Checked == true)//3TDEA
                {
                    strKey = strDesKey1 + strDesKey2 + strDesKey3;
                }
                baKey = TDEA.ToByteArray(strKey);

                if (chkDesCbcMode.Checked == true)
                {
                    //CBC Mode
                    byte[] baIV = TDEA.ToByteArray(strDesCbcIV);
                    baCypherData = TDEA.CbcEncryption(baKey, baIV, baPlainData);
                }
                else
                {
                    //ECB Mode
                    baCypherData = TDEA.EcbEncryption(baKey, baPlainData);
                }

                strCypherData = BitConverter.ToString(baCypherData).Replace('-', ' ');
                txtDesCypherData.Text = strCypherData;
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void btnDesDecryption_Click(object sender, EventArgs e)
        {
            try
            {
                string strDesKey1 = txtDesKey1.Text.Replace(" ", "");
                string strDesKey2 = txtDesKey2.Text.Replace(" ", "");
                string strDesKey3 = txtDesKey3.Text.Replace(" ", "");
                string strDesCbcIV = txtDesCbcIV.Text.Replace(" ", "");
                string strDesPlainData = txtDesPlainData.Text.Replace(" ", "");
                string strKey = strDesKey1; //Default value for DES 
                byte[] baKey;
                byte[] baPlainData;
                byte[] baCypherData = new byte[0];
                string strCypherData;

                if (String.IsNullOrEmpty(strDesKey1))
                {
                    txtMessage.Text = mlText.AddLine("Error: The field of Key1 can't be empty.");
                    return;
                }

                if (strDesKey1.Length < 16)
                {
                    txtMessage.Text =
                        mlText.AddLine(String.Format("Error: The length of Key 1 is {0} but it should be 16",
                                         strDesKey1.Length));
                    return;
                }

                if (String.IsNullOrEmpty(strDesPlainData))
                {
                    txtMessage.Text = mlText.AddLine("Error: The field of Plain Data can't be empty.");
                    return;
                }

                if (chkDesCbcMode.Checked == true &&
                    String.IsNullOrEmpty(strDesCbcIV))
                {
                    strDesCbcIV = "0000000000000000"; //Default Value
                    txtDesCbcIV.Text = strDesCbcIV;
                }

                if (radioDES.Checked == false &&  //The Key2 can't be empty if not in single DES mode.
                    String.IsNullOrEmpty(strDesKey2))
                {
                    strDesKey2 = strDesKey1;
                    txtDesKey2.Text = strDesKey2;
                }

                if (radio3TDEA.Checked == true &&  //The Key3 can't be empty in this case
                    String.IsNullOrEmpty(strDesKey3))
                {
                    strDesKey3 = strDesKey1;
                    txtDesKey3.Text = strDesKey3;
                }

                baPlainData = TDEA.ToByteArray(strDesPlainData);

                if (radio2TDEA.Checked == true)//2TDEA
                {
                    strKey = strDesKey1 + strDesKey2;
                }
                else if (radio3TDEA.Checked == true)//3TDEA
                {
                    strKey = strDesKey1 + strDesKey2 + strDesKey3;
                }
                baKey = TDEA.ToByteArray(strKey);

                if (chkDesCbcMode.Checked == true)
                {
                    //CBC Mode
                    byte[] baIV = TDEA.ToByteArray(strDesCbcIV);
                    baCypherData = TDEA.CbcDecryption(baKey, baIV, baPlainData);
                }
                else
                {
                    //ECB Mode
                    baCypherData = TDEA.EcbDecryption(baKey, baPlainData);
                }

                strCypherData = BitConverter.ToString(baCypherData).Replace('-', ' ');
                txtDesCypherData.Text = strCypherData;
            }
            catch (Exception ex)
            {
                txtMessage.Text = mlText.AddLine(ex.Message);
            }
        }

        private void btnThsrcSamAuthen_Click(object sender, EventArgs e)
        {
            try
            {
                mIsThsrcSamAuthed = false;
                mIsPiccAuthened = false;

                ///Read Key data from THSRC key file
                mThsrcKeyFileData = System.IO.File.ReadAllBytes(txtThsrcKeyFile.Text);
                //string strThsrcBinKey = BitConverter.ToString(mThsrcKeyFileData).Replace('-', ' ');
                //mlText.AddLine("The original key data from bin file is " + strThsrcBinKey);
                //mlText.AddLine(String.Format("Read key data from {0} is done!", txtThsrcKeyFile.Text));

                if (mThsrcKeyFileData.Length < 17)
                {
                    mlText.AddLine(String.Format("Error: The length of KeyFile data is {0}, but it should be 17",
                                                  mThsrcKeyFileData.Length));
                    return;
                }

                mRespApdu = mPcscReader.Exchange("8060000000"); //Get SAM Version
                if (mRespApdu.SW1SW2 == 0x9000)
                {
                    Array.Copy(mRespApdu.Data, 14, mThsrcSamSN, 0, 7); //Get SAM Serial Number
                    Array.Clear(mThsrcSamSN, 7, 9);
                }
                else
                {
                    mlText.AddLine(String.Format("Error: Get SAM Version error, SW={0}",
                                                  mRespApdu.SW1SW2));
                    return;
                }

                Array.Copy(mThsrcKeyFileData, mThsrcOrgKey, 16);
                mThsrcUsageMasterKey = TDEA.CbcDecryption(mThsrcFileProtectKey, mThsrcIV, mThsrcOrgKey);
                
                byte chksum = 0;
                for (int i = 0; i < 16; i++)
                    chksum ^= mThsrcUsageMasterKey[i];

                if (chksum != mThsrcKeyFileData[16])
                {
                    mlText.AddLine("Error: THSRC Master Key check sum error. The Master Key is invalid");
                    return;
                }

                mThsrcUsageKey = TDEA.CbcEncryption(mThsrcUsageMasterKey, mThsrcIV, mThsrcSamSN);

                /// The following statements just used to trace code.
                mlText.AddLine("THSRC Usage Master Key: " + BitConverter.ToString(mThsrcUsageMasterKey).Replace('-', ' '));
                mlText.AddLine("THSRC SAM SerialNumber: " + BitConverter.ToString(mThsrcSamSN).Replace('-', ' '));
                mlText.AddLine("THSRC Usage Key       : " + BitConverter.ToString(mThsrcUsageKey).Replace('-', ' '));

                // Host Authentication Part 1
                mlText.NewLine();
                mlText.AddLine("== SAM_AuthenticationHost, Part1 ==");
                ushort uSW = SendShowApdu("80A4000002000100"); //KeyNo:00, KeyVer:01

                if (uSW != 0x90AF)
                {
                    mlText.AddLine("Error: SAM_AuthenticationHost Part1 was failed.");
                    return;
                }
                mlText.AddLine("Response:" + BitConverter.ToString(mRespApdu.Data).Replace('-', ' '));

                byte[] baRndB = TDEA.CbcDecryption(mThsrcUsageKey, mThsrcIV, mRespApdu.Data);
                mlText.AddLine("Rand B  :" + BitConverter.ToString(baRndB).Replace('-', ' '));

                byte[] baRndA = new byte[8];
                byte[] baRndABr = new byte[16];
                TDEA.GetRandoms(baRndA);
                Array.Copy(baRndA, baRndABr, 8);

                //Left rotate RndB
                Array.Copy(baRndB, 1, baRndABr, 8, 7);
                baRndABr[15] = baRndB[0]; //baRndB is left rotated one byte.

                byte[] baEncRndABr = TDEA.CbcEncryption(mThsrcUsageKey, mThsrcIV, baRndABr);
                string strEncRndABr = TDEA.ToHexString(baEncRndABr);

                // Host Authentication Part 2
                mlText.NewLine();
                mlText.AddLine("== SAM_AuthenticationHost, Part2 ==");
                mlText.AddLine("Rand A   :" + BitConverter.ToString(baRndA).Replace('-', ' '));
                mlText.AddLine("Rand A+Br:" + BitConverter.ToString(baRndABr).Replace('-', ' '));

                string strApdu = String.Format("80A4000010{0}00", strEncRndABr);
                uSW = SendShowApdu(strApdu); 

                if(uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_AuthenticationHost Part2 was failed.");
                    return;
                }

                byte[] baRndAr = new byte[8];
                Array.Copy(baRndA, 1, baRndAr, 0, 7);
                baRndAr[7] = baRndA[0]; //baRndA is left rotated one byte.
                byte[] baRespRndAr = TDEA.CbcDecryption(mThsrcUsageKey, mThsrcIV, mRespApdu.Data);


                mlText.AddLine("Rand A'  :" + BitConverter.ToString(baRndAr).Replace('-', ' '));
                mlText.AddLine("RespRndA':" + BitConverter.ToString(baRespRndAr).Replace('-', ' '));

                if (baRndAr.SequenceEqual(baRespRndAr) == false)
                {
                    mlText.AddLine("Error: The response of RndA is incorrect.");
                    return;
                }

                mIsThsrcSamAuthed = true;

                //Generate THSRC 2TDEA Session Key
                Array.Copy(baRndA, 0, mThsrcSessionKey, 0, 4);
                Array.Copy(baRndB, 0, mThsrcSessionKey, 4, 4);
                Array.Copy(baRndA, 4, mThsrcSessionKey, 8, 4);
                Array.Copy(baRndB, 4, mThsrcSessionKey, 12, 4);

                mlText.NewLine();
                mlText.AddLine("== Generate THSRC Session Key ==");
                mlText.AddLine("THSRC Session Key : " + BitConverter.ToString(mThsrcSessionKey).Replace('-', ' '));
                mlText.NewLine();
                mlText.AddLine("== 高鐡 SAM AV2 認證成功 ==");
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void btnGenRandom_Click(object sender, EventArgs e)
        {
            byte[] baRnd = new byte[8];
            TDEA.GetRandoms(baRnd);
            txtRandomNumber.Text = BitConverter.ToString(baRnd).Replace('-', ' ');
        }

        private int ParsePortNum(string strPortNum)
        {
            char[] caPortNum = strPortNum.ToCharArray();
            int nPortNum = 0;

            for (int i = 0; i < caPortNum.Length; i++)
            {
                if (Char.IsNumber(caPortNum[i]))
                {
                    nPortNum = nPortNum * 10 + int.Parse(caPortNum[i].ToString());
                }
                else
                {
                    break;
                }
            }

            return (nPortNum - 1); //if nPortNum == 0 then return -1;
        }

        /// <summary>
        /// Process ComPort Button Click event. Steven Liu 2015/04/07
        /// </summary>
        private bool OnComOpenClick()
        {
            try
            {
                string PortName = (string)comboComPorts.SelectedItem;
                byte[] baSamSlots = new byte[8];

                //Note. The PortName may be attched some garbage char behind the end.
                //SelectedPortNo = Convert.ToInt32(PortName.Remove(0, 3)) - 1;
                mSelectedPortNo = ParsePortNum(PortName.Remove(0, 3));

                if (mSelectedPortNo < 0)
                {
                    mlText.AddLine("Invalid PortNum: " + mSelectedPortNo);
                    return false;
                }

                int rtn = MrdDll.MRD_Open(mSelectedPortNo, baSamSlots);

                if (rtn != 0)
                {
                    txtFwVersion.Text = "N/A";
                    //mlText.AddLine(String.Format("Open COM {0} failed.", SelectedPortNo + 1));
                    return false;
                }

                mlText.AddLine(String.Format("Com {0} Open Succeeded",
                    mSelectedPortNo + 1));

                mlText.AddLine("NOTE: Only Antenna 1 can be used in this program.");

                btnComOpen.Enabled = false;
                btnComClose.Enabled = true;

                btnPiccAuthen.Enabled = true;
                btnPiccCardRequest.Enabled = true;
                btnPiccRead.Enabled = true;
                btnPiccWrite.Enabled = true;
                btnPiccAuthenAllSecs.Enabled = true;

                comboComPorts.Enabled = false;
                mIsPortOpened = true;

                byte[] baFwVersion = new byte[20];

                uint readStartTime = Utilities.GetSystemTickTime();
                rtn = MrdDll.MRD_FW_Version(baFwVersion);
                uint readSpentTime = Utilities.GetTickSpan(readStartTime);

                if (rtn == 0)
                {
                    txtFwVersion.Text = System.Text.Encoding.Default.GetString(baFwVersion);
                    mlText.AddLine(String.Format("讀取韌體版本 {0} 成功, [SpentTime: {1}]",
                        txtFwVersion.Text,
                        readSpentTime));
                }
                else
                {
                    mlText.AddLine(String.Format("讀取韌體版本失敗, [SpentTime: {0}]",
                        readSpentTime));
                    txtFwVersion.Text = "Unknown";
                }

                return true;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString()); //for debug only
                return false;
            }
        }

        private void btnComOpen_Click(object sender, EventArgs e)
        {
            //txtMessage.Text = mlText.Clear(); //???
            if (OnComOpenClick() == false)
            {
                MrdDll.MRD_Close(mSelectedPortNo);
                mIsPortOpened = false;

                MessageBox.Show("Open COM Port 失敗");
                mlText.AddLine(String.Format("COM{0} 開啟失敗, 請確認讀卡機是否己上電及正確連接",
                    (mSelectedPortNo + 1)));
            }
            txtMessage.Text = mlText.Text;
            txtAPDU.Focus();
        }

        private void OnComCloseClick()
        {
            MrdDll.MRD_Close(mSelectedPortNo);
            mIsPortOpened = false;

            btnComOpen.Enabled = true;
            btnComClose.Enabled = false;

            comboComPorts.Enabled = true;
            txtFwVersion.Text = "";

            btnPiccAuthen.Enabled = false;
            btnPiccCardRequest.Enabled = false;
            btnPiccRead.Enabled = false;
            btnPiccWrite.Enabled = false;
            btnPiccAuthenAllSecs.Enabled = false;

            btnExit.Focus();
        }

        private void btnComClose_Click(object sender, EventArgs e)
        {
            OnComCloseClick();
        }


        private bool PiccCardRequest()
        {
            try
            {
                if (mIsPiccAuthened)
                    KillAuthen();

                bool rtnStatus = false;
                Array.Clear(mbaCardSnr, 0, mbaCardSnr.Length);
                mstrCardSnr = "(N/A)";
                mbSnrLen = 0;
                Array.Clear(mbaATQA, 0, mbaATQA.Length);
                mSAK = 0;
                mIsPiccExisted = false;

                uint startTick = Utilities.GetSystemTickTime();
                int result = MrdDll.MifareCardRequest(mbaCardSnr, ref mbSnrLen, mbaATQA, ref mSAK);
                mSpentTime = Utilities.GetTickSpan(startTick);

                if (result == 0 && mbSnrLen > 0)
                {
                    mstrCardSnr = BitConverter.ToString(mbaCardSnr).Substring(0, mbSnrLen * 3-1).Replace('-', ' ');
                    MrdDll.BUZZER_Control_ON(1, 1);
                    rtnStatus = true;
                    mIsPiccExisted = true;
                }

                mlText.NewLine();
                mlText.AddLine(String.Format("CardRequest: Return Code: {0}h({1}), SNR: {2}, SnrLen={3},  ATQA: {4} {5}, SAK: {6}, [Time:{7}ms]",
                                                    result.ToString("X2"), result.ToString(),
                                                    mstrCardSnr, mbSnrLen,
                                                    mbaATQA[0].ToString("X2"), mbaATQA[1].ToString("X2"),
                                                    mSAK.ToString("X2"),
                                                    mSpentTime));
                txtPiccSN.Text = mstrCardSnr;

                return rtnStatus;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void btnPiccCardRequest_Click(object sender, EventArgs e)
        {
            try
            {
                if(mIsThsrcSamAuthed == false)
                    btnThsrcSamAuthen_Click(sender, e);

                PiccCardRequest();
                /*
                if (PiccCardRequest() == false)
                {
                    if (mIsPiccAuthened)
                        KillAhthen();
                }
                 * */
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        /// <summary>
        /// Mifare authentication Part 1
        /// </summary>
        /// <param name="bAuthMode">0x60 for KeyA, 0x61 for KeyB</param>
        /// <param name="bBlkNo">Block number, 0 ~ 63</param>
        /// <param name="baTokenRB">Token RB which returned from PICC, 5 Bytes.</param>
        /// <returns></returns>
        private int PiccAuthPart1(byte bAuthMode, byte bBlkNo, byte[] baTokenRB)
        {
            int rc = -1;
            try
            {
                byte[] baAuthCmd = new byte[2];
                UInt16 uRecvLen = 0;

                mlText.AddLine(" *** PiccAuthPart1() *** ");
                if (mIsPiccAuthened == false)
                {
                    baAuthCmd[0] = bAuthMode;
                    baAuthCmd[1] = bBlkNo;

                    mlText.AddLine(" --- Send raw AuthCmd to PICC and get Token RB from PICC --- ");
                    //rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_TxCRCEnable | MrdDll.MODE_ParityEnable,
                    //                baAuthCmd, 2, baTokenRB, ref uRecvLen);
                    rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_TxCRCEnable | MrdDll.MODE_ParityEnable,
                                    baAuthCmd, 2*8, baTokenRB, ref uRecvLen);
                    baTokenRB[4] = 0;
                    mlText.AddLine(String.Format("PcdLowLTransceive Raw AuthCmd: Return Code: {0}h({1})",
                                                        rc.ToString("X2"), rc.ToString()));
                    mlText.AddLine(" Sent Raw AuthCmd: " + TDEA.ToHexString(baAuthCmd));
                }
                else //The mifare card has been authened and a new authen on existing authen is required.
                {
                    //SAM_Encipher_Data from SAM AV2
                    mlText.AddLine(String.Format(" --- SAM_Encipher_Data (Auth= {0}, Blk= {1}) from AV2 ---",
                                                bAuthMode.ToString("X2"),
                                                bBlkNo.ToString("X2")));

                    string strApduCmd = String.Format("80ED000002{0}{1}00",
                                                bAuthMode.ToString("X2"),
                                                bBlkNo.ToString("X2"));
                    ushort uSW = SendShowApdu(strApduCmd); //KeyNo:00, KeyVer:01

                    if (uSW != 0x9000)
                    {
                        mlText.AddLine("Error: SAM_Encipher_Data(Auth, Addr) for Mifare Authen was failed.");
                        return 1001;
                    }

                    mlText.NewLine();
                    mlText.AddLine(" --- Sent Enciphered AuthCmd to PICC and get Token RB from PICC --- ");
                    //Send the response from AV2 to Mifare Card
                    //rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_ISO14443A,
                    //                mRespApdu.Data, 5, 
                    //                baTokenRB, ref uRecvLen);
                    rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_ISO14443A,
                                    mRespApdu.Data, (4*8 + 4),
                                    baTokenRB, ref uRecvLen);
                    mlText.AddLine(String.Format("PcdLowLTransceive Enciphered AuthCmd: Return Code: {0}h({1})",
                                                        rc.ToString("X2"), rc.ToString()));
                    mlText.AddLine(" Sent Raw AuthCmd: " + TDEA.ToHexString(mRespApdu.Data));
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return rc;
        }

        /// <summary>
        /// Authencates between SAM AV2 and PICC
        /// </summary>
        /// <param name="bBlkNo"> Mifare Block Number, 0 ~ 63</param>
        /// <param name="bKeyType"> Mifare Key Type: KeyA: 0x0A, KeyB: 0x0B.</param>
        private bool PiccAuthen(byte bBlkNo, byte bKeyType)
        {
            try
            {
                //=== Check PICC UID ===
                if (mbSnrLen < 4)
                {
                    mlText.AddLine("Error: Mifar Card Serial Number not found!");
                    return false;
                }

                //=== Mifare Authentication Part 1 ===
                //++++ Get Token RB from PICC ++++++ 
                string strTokenRB = "(None)";
                byte[] baTokenRB = new byte[5]; //[4];
                byte bAuthMode = (bKeyType == 0x0A) ? (byte)0x60 : (byte)0x61;
                string strKeyType = (bKeyType == 0x0A) ? "Key A" : "Key B";
                //byte bBlkNo = byte.Parse(txtPiccBlockNo.Text);

                mlText.NewLine();
                mlText.AddLine(String.Format("=== Mifare Authentication, KeyType: {0}, BlockNo: {1}  ===",
                                      strKeyType, bBlkNo));
                mlText.AddLine(" --- Get Token RB from PICC --- ");

                uint startTick = Utilities.GetSystemTickTime();
                //int rc = MrdDll.PcdAuthPart1(1, bAuthMode, bBlkNo, baTokenRB);
                int rc = PiccAuthPart1(bAuthMode, bBlkNo, baTokenRB);
                uint spanTime = Utilities.GetTickSpan(startTick);

                mlText.AddLine(String.Format("PcdAuthPart1,Auth:{0}h - {1}, Block:{2}, Return Code:{3}h({4}) [Time:{5}ms]",
                                    bAuthMode.ToString("X2"),
                                    strKeyType,
                                    bBlkNo.ToString(),
                                    rc.ToString("X2"), rc.ToString(),
                                    spanTime));
                if (rc == 0)
                {
                    //strTokenRB = BitConverter.ToString(baTokenRB).Replace('-', ' ');
                    strTokenRB = TDEA.ToHexString(baTokenRB);
                }
                else
                {
                    mlText.AddLine("Error: Get Token RB from PICC failed");
                    return false;
                }
                mlText.AddLine(String.Format("Token RB: {0}", strTokenRB));

                mlText.NewLine();
                mlText.AddLine(" --- Run SAM_AuthenticationMIFARE-Part1 ---");

                byte[] baPiccUid = new byte[4];
                Array.Copy(mbaCardSnr, ((int)mbSnrLen - 4), baPiccUid, 0, 4); //Get the last 4 bytes of Card UID
                string strPiccUid = TDEA.ToHexString(baPiccUid);
                //byte bKeyType = (radioPiccKeyA.Checked) ? (byte)0x0A : (byte)0x0B;
                byte bSamKeyNo = (radioIssuerThsrc.Checked) ? ThsrcKeyMap.BlockToKeyNo(bBlkNo, bKeyType)
                                                            : EasyCardKeyMap.BlockToKeyNo(bBlkNo, bKeyType);
                byte bSamKeyVer = (radioIssuerThsrc.Checked) ? ThsrcKeyMap.BlockToKeyVer(bBlkNo)
                                                             : EasyCardKeyMap.BlockToKeyVer(bBlkNo);
                byte bDivBlkNo = (byte)(((bBlkNo / 4) * 4) + 3);// 0; //Div Block Number

                //string strApduCmd = String.Format("801C00000E{0}{1}{2}{3}{4}{5}00{6}00", //used for 4bytes of TokenRB
                string strApduCmd = String.Format("801C00000E{0}{1}{2}{3}{4}{5}{6}00",
                                            strPiccUid,
                                            bSamKeyNo.ToString("X2"),
                                            bSamKeyVer.ToString("X2"),
                                            bKeyType.ToString("X2"),
                                            bBlkNo.ToString("X2"),
                                            strTokenRB,
                                            bDivBlkNo.ToString("X2"));
                ushort uSW = SendShowApdu(strApduCmd); //KeyNo:00, KeyVer:01

                if (uSW != 0x90AF)
                {
                    mlText.AddLine("Error: SAM_AuthenticationMIFARE Part1 was failed.");
                    return false;
                }

                string strTokenAB = BitConverter.ToString(mRespApdu.Data).Replace('-', ' ');
                mlText.AddLine("ek(TokenAB): " + strTokenAB);

                //=== Mifare Authentication Part 2 ===
                //++++ Send Token AB to PICC and retrieve Token BA from PICC  ++++++ 

                mlText.NewLine();
                mlText.AddLine("== Mifare Authentication, Part 2 ==");
                mlText.AddLine(" --- Send Token AB to PICC and retrieve Token BA from PICC --- ");

                byte[] baTokenBA = new byte[5];
                string strTokenBA;
                UInt16 uRecvLen = 0;
                startTick = Utilities.GetSystemTickTime();
                //rc = MrdDll.PcdAuthPart2(1, mRespApdu.Data, baTokenBA);
                //rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_ISO14443A,
                //                mRespApdu.Data, 9,
                //                baTokenBA, ref uRecvLen);
                rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_ISO14443A,
                                mRespApdu.Data, 9*8,
                                baTokenBA, ref uRecvLen);
                spanTime = Utilities.GetTickSpan(startTick);

                mlText.AddLine(String.Format("PcdLowLTransceive Token AB: Return Code:{0}h({1}) [Time:{2}ms]",
                                    rc.ToString("X2"), rc.ToString(),
                                    spanTime));
                mlText.AddLine(String.Format(" SendData(Token AB): {0}", strTokenAB));
                if (rc == 0)
                {
                    strTokenBA = TDEA.ToHexString(baTokenBA);
                }
                else
                {
                    strTokenBA = "0000000000";
                    mlText.AddLine("Error: Get Token BA from PICC failed");
                    //return false; //Don't return to complete the total authen procedure.
                }
                mlText.AddLine(String.Format("Received Token BA: {0}", strTokenBA));

                mlText.NewLine();
                mlText.AddLine(" --- Run SAM_AuthenticationMIFARE-Part2 ---");

                strApduCmd = String.Format("801C000005{0}", strTokenBA);
                //strApduCmd = String.Format("821C000005{0}", strTokenBA);

                uSW = SendShowApdu(strApduCmd); //KeyNo:00, KeyVer:01

                if (uSW == 0x9000)
                {
                    mlText.AddLine("SAM_AuthenticationMIFARE Succeeded.");
                    mlText.AddLine(String.Format("=== 高鐡感應卡, KeyType: {0}, BlockNo: {1} 認證成功 ===",
                                          strKeyType, bBlkNo));
                    mIsPiccAuthened = true;
                    return true;
                }
                else
                {
                    mlText.AddLine("Error: SAM_AuthenticationMIFARE Part2 was failed.");
                    return false;
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void btnPiccAuthen_Click(object sender, EventArgs e)
        {
            try
            {
                if (mIsThsrcSamAuthed == false)
                    btnThsrcSamAuthen_Click(sender, e);

                if (mIsPiccExisted == false)
                {
                    if (PiccCardRequest() == false)
                        return;
                }

                byte bBlkNo = byte.Parse(txtPiccBlockNo.Text);
                byte bKeyType = (radioPiccKeyA.Checked) ? (byte)0x0A : (byte)0x0B;
                if (PiccAuthen(bBlkNo, bKeyType) == false)
                {
                    if (mIsPiccAuthened)
                        KillAuthen();

                    mIsPiccExisted = false;
                }
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private void btnPiccAuthenAllSecs_Click(object sender, EventArgs e)
        {
            try
            {
                byte bKeyType = (radioPiccKeyA.Checked) ? (byte)0x0A : (byte)0x0B;
                string  strKeyType = (radioPiccKeyA.Checked) ? "Key A" : "Key B";
                string strIssuer = (radioIssuerThsrc.Checked) ? "THSRC" : "EasyCard";
                int nBlkNo = 0;
                int nSecNo = 0;

                if (mIsThsrcSamAuthed == false)
                    btnThsrcSamAuthen_Click(sender, e);

                if (PiccCardRequest() == false)
                {
                    mlText.AddLine("Card Request failed. No card exist.");
                    return;
                }

                mlText.NewLine();
                mlText.AddLine(String.Format("#### {0} PICC Authen Test ####", strIssuer));

                tabControl.Enabled = false;
                for (nSecNo = 0; nSecNo < 16; nSecNo++)
                {
                    mlText.NewLine();
                    mlText.AddLine(String.Format("**** Sector {0}: Authentication test with {1} ****", nSecNo, strKeyType));

                    nBlkNo = nSecNo * 4;
                    if (PiccAuthen((byte)nBlkNo, bKeyType) == false)
                    {  //The PICC will back to IDLE mode if Card Authen failed.
                        if (PiccCardRequest() == false)
                        {
                            mlText.AddLine(String.Format("Card Request at sector {0} failed.", nSecNo));
                            break;
                        }
                    }
                }
                tabControl.Enabled = true;
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }


        private bool PiccReadBlk(byte bBlkNo, byte[] baBlkData)
        {
            try
            {
                byte[] baEncBlkData = new byte[21]; //The enciphered block data from PICC
                string strEncBlkData = "";
                UInt16 uRecvLen = 0;
                ushort uSW = 0;

                mlText.NewLine();
                //SAM_Encipher_Data (ReadCmd, BlkNo)
                mlText.AddLine(String.Format(" --- SAM_Encipher_Data (ReadCmd= 0x30, BlkNo= {0}({1}h)) from AV2 ---",
                                            bBlkNo.ToString(), bBlkNo.ToString("X2")));

                string strApduEncCmd = String.Format("80ED00000230{0}00",
                                            bBlkNo.ToString("X2"));
                uSW = SendShowApdu(strApduEncCmd); 

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Encipher_Data(Read, Addr) for Mifare Read was failed.");
                    return false;
                }

                mlText.NewLine();
                mlText.AddLine(" --- Send Read Cmd to PICC and try to receive 21-byte response --- ");
                //Send the response from AV2 to Mifare Card
                //int rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_ISO14443A,
                //                mRespApdu.Data, 5,
                //                baEncBlkData, ref uRecvLen);
                int rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_ISO14443A,
                                mRespApdu.Data, (4*8 + 4),
                                baEncBlkData, ref uRecvLen);
                mlText.AddLine(String.Format("PcdLowLTransceive Enciphered Read Cmd: Return Code: {0}h({1})",
                                                    rc.ToString("X2"), rc.ToString()));
                if (rc != 0)
                {
                    mlText.AddLine("Error: PcdLowLTransceive(Read, Addr) for Mifare Read was failed.");
                    return false;
                }

                strEncBlkData = TDEA.ToHexString(baEncBlkData);
                mlText.AddLine(String.Format(" Read Data: {0}", strEncBlkData));
                
                //SAM_Decipher_Data (ReadData)
                mlText.NewLine();
                mlText.AddLine(" --- SAM_Decipher_Data ---");

                string strApduDecCmd = String.Format("80DD000015{0}00", strEncBlkData);
                uSW = SendShowApdu(strApduDecCmd); 

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Decipher_Data for Mifare Read was failed.");
                    return false;
                }
                Array.Copy(mRespApdu.Data, baBlkData, 16);
                return true;
            }
            catch(Exception ex)
            {
                throw ex;
            }
        }


        private void btnPiccRead_Click(object sender, EventArgs e)
        {
            try
            {
                byte bBlkNo = byte.Parse(txtPiccBlockNo.Text);
                byte[] baBlkData = new byte[16];
                string strBlkData = "(null)";

                uint startTick = Utilities.GetSystemTickTime();
                //int result = MrdDll.PcdRead(0x01, 0x01, bBlkNo, baBlkData);
                bool result = PiccReadBlk(bBlkNo, baBlkData);
                mSpentTime = Utilities.GetTickSpan(startTick);

                if (result)
                {
                    strBlkData = BitConverter.ToString(baBlkData).Replace('-', ' ');
                }

                mlText.NewLine();
                mlText.AddLine(String.Format("PiccReadBlk Block {0}, Result: {1} [Time:{2}ms]",
                                                    bBlkNo,
                                                    result,
                                                    mSpentTime));
                mlText.AddLine(String.Format(" Read Data: {0}", strBlkData));
                txtPiccReadData.Text = strBlkData;
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }

        private bool KillAuthen()
        {
            try
            {
                // SAM_KillAuthentication
                mlText.NewLine();
                mlText.AddLine("== SAM_KillAuthentication ==");
                ushort uSW = SendShowApdu("80CA0000"); //KeyNo:00, KeyVer:01

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_KillAuthentication was failed.");
                    return false;
                }

                if (mIsPiccAuthened)
                {
                    mIsPiccAuthened = false;
                    mlText.AddLine("SAM-Mifare Auhen and Mifare Session Key have been killed. The flag mIsPiccAuthened is set to FALSE");
                }
                else if (mIsThsrcSamAuthed)
                {
                    //mIsThsrcSamAuthed = false;
                    mlText.AddLine("SAM-Host Session Key has been killed but the flag mIsThsrcSamAuthed is still set to TRUE.");
                }
                else
                    mlText.AddLine("No Athen was established and nothing to be killed.");
                return true;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void btnKillAuthen_Click(object sender, EventArgs e)
        {
            try
            {
                KillAuthen();
                mIsPiccExisted = false; //Another new CardRequest is required is PICC authened is killed.
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }


        private bool PiccWriteBlk(byte bBlkNo, byte[] baBlkData)
        {
            try
            {
                UInt16 uRecvLen = 0;
                ushort uSW = 0;

                mlText.NewLine();
                //SAM_Encipher_Data (WriteCmd, BlkNo)
                mlText.AddLine(String.Format(" --- SAM_Encipher_Data (WriteCmd= 0xA0, BlkNo= {0}({1}h)) from AV2 ---",
                                            bBlkNo.ToString(), bBlkNo.ToString("X2")));

                string strApduEncCmd = String.Format("80ED000002A0{0}00",
                                            bBlkNo.ToString("X2"));
                uSW = SendShowApdu(strApduEncCmd);

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Encipher_Data(Write, Addr) for Mifare Write was failed.");
                    return false;
                }

                mlText.NewLine();
                mlText.AddLine(" --- Send Write Cmd to PICC and try to receive an one byte enciphered ACK --- ");
                //Send the response from AV2 to Mifare Card
                byte[] baEncAck = new byte[1];
                //int rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_ISO14443A,
                //                mRespApdu.Data, 5,
                //                baEncAck, ref uRecvLen);
                int rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_ISO14443A,
                                mRespApdu.Data, (4*8 + 4),
                                baEncAck, ref uRecvLen);

                mlText.AddLine(String.Format("PcdLowLTransceive Enciphered Write Cmd: Return Code: {0}h({1})",
                                                    rc.ToString("X2"), rc.ToString()));
                mlText.AddLine(" Sent EncCmd: " + TDEA.ToHexString(mRespApdu.Data));
                if (rc != 0)
                {
                    mlText.AddLine("Error: PcdLowLTransceive(Write, Addr) for Mifare Write was failed.");
                    return false;
                }

                mlText.AddLine(String.Format(" Received ACK: {0}", baEncAck[0].ToString("X2")));

                //SAM_Decipher_Data (ReadData)
                mlText.NewLine();
                mlText.AddLine(" --- SAM_Decipher_Data(ACK) ---");

                string strApduDecCmd = String.Format("80DD000001{0}00", baEncAck[0].ToString("X2"));
                uSW = SendShowApdu(strApduDecCmd);

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Decipher_Data for Mifare ACK was failed.");
                    return false;
                }
                
                if (mRespApdu.Data[0] != 0x0A)
                {
                    mlText.AddLine(String.Format(" Error: The Deciphered ACK != 0x0A, it is {0}", 
                        mRespApdu.Data[0].ToString("X2")));
                    return false;
                }

                mlText.NewLine();
                string strBlkData = TDEA.ToHexString(baBlkData);
                //SAM_Encipher_Data (WriteData)
                mlText.AddLine(String.Format(" --- SAM_Encipher_Data (WriteData = {0}) from AV2 ---",
                                            strBlkData));

                string strApduWriteData = String.Format("80ED000010{0}00", strBlkData);
                uSW = SendShowApdu(strApduWriteData);

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Encipher_Data(WriteData) for Mifare Write was failed.");
                    return false;
                }

                mlText.NewLine();
                mlText.AddLine(" --- Send WriteData to PICC and try to receive an one byte enciphered ACK --- ");
                //Send the response from AV2 to Mifare Card
                //rc = MrdDll.PcdLowLTransceive(MrdDll.MODE_ISO14443A,
                //                mRespApdu.Data, 21,
                //                baEncAck, ref uRecvLen);
                rc = MrdDll.PcdBitsTransceive(MrdDll.MODE_ISO14443A,
                                mRespApdu.Data, (20*8 + 2),
                                baEncAck, ref uRecvLen);

                mlText.AddLine(String.Format("PcdLowLTransceive Enciphered WriteData: Return Code: {0}h({1})",
                                                    rc.ToString("X2"), rc.ToString()));
                
                string strEncBlkData = TDEA.ToHexString(mRespApdu.Data);
                mlText.AddLine(" Sent EncData: " + strEncBlkData);
                if (rc != 0)
                {
                    mlText.AddLine("Error: PcdLowLTransceive(WriteData) for Mifare Write was failed.");
                    return false;
                }

                mlText.AddLine(String.Format(" Received ACK: {0}", baEncAck[0].ToString("X2")));

                //SAM_Decipher_Data (ReadData)
                mlText.NewLine();
                mlText.AddLine(" --- SAM_Decipher_Data(ACK) ---");

                strApduDecCmd = String.Format("80DD000001{0}00", baEncAck[0].ToString("X2"));
                uSW = SendShowApdu(strApduDecCmd);

                if (uSW != 0x9000)
                {
                    mlText.AddLine("Error: SAM_Decipher_Data for Mifare ACK was failed.");
                    return false;
                }

                if (mRespApdu.Data[0] != 0x0A)
                {
                    mlText.AddLine(String.Format(" Error: The Deciphered ACK != 0x0A, it is {0}",
                        mRespApdu.Data[0].ToString("X2")));
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void btnPiccWrite_Click(object sender, EventArgs e)
        {
            try
            {
                byte bBlkNo = byte.Parse(txtPiccBlockNo.Text);
                string strBlkData = txtPiccWriteData.Text.Replace(" ", "");
                byte[] baBlkData = TDEA.ToByteArray(strBlkData);

                uint startTick = Utilities.GetSystemTickTime();
                bool result = PiccWriteBlk(bBlkNo, baBlkData);
                mSpentTime = Utilities.GetTickSpan(startTick);

                mlText.NewLine();
                mlText.AddLine(String.Format("PiccWriteBlk Block {0}, Result: {1} [Time:{2}ms]",
                                                    bBlkNo,
                                                    result,
                                                    mSpentTime));
                mlText.AddLine(String.Format(" Wrote Data: {0}", strBlkData));
            }
            catch (Exception ex)
            {
                mlText.AddLine(ex.Message);
            }
            finally
            {
                txtMessage.Text = mlText.Text;
            }
        }
    }
}
